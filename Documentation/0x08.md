## 1. Замена "магических чисел" именованными константами

**До:**
```c
double calculateCircleArea(double radius) {
    return 3.14159 * radius * radius;
}
```

**После:**
```c
#define PI 3.14159

double calculateCircleArea(double radius) {
    return PI * radius * radius;
}
```

**Описание:** Замена "магического числа" 3.14159 именованной константой улучшает читаемость и облегчает поддержку.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 6/10
- Надежность: 7/10

## 2. Разделение длинной функции на подфункции

**До:**
```c
void processUserData(User *user) {
    // Проверка имени
    if (strlen(user->name) > 50) {
        printf("Name too long\n");
        return;
    }
    
    // Проверка возраста
    if (user->age < 0 || user->age > 120) {
        printf("Invalid age\n");
        return;
    }
    
    // Сохранение в базу
    // ... много кода ...
}
```

**После:**
```c
bool validateUserName(const char *name) {
    return strlen(name) <= 50;
}

bool validateUserAge(int age) {
    return age >= 0 && age <= 120;
}

void saveUserToDatabase(User *user) {
    // ... код сохранения ...
}

void processUserData(User *user) {
    if (!validateUserName(user->name)) {
        printf("Name too long\n");
        return;
    }
    
    if (!validateUserAge(user->age)) {
        printf("Invalid age\n");
        return;
    }
    
    saveUserToDatabase(user);
}
```

**Описание:** Разделение большой функции на меньшие с четкими обязанностями.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 9/10
- Производительность: 1/10
- Безопасность: 7/10
- Надежность: 8/10

## 3. Замена цепочки if-else на switch

**До:**
```c
void handleCommand(int cmd) {
    if (cmd == 1) {
        start();
    } else if (cmd == 2) {
        stop();
    } else if (cmd == 3) {
        pause();
    } else {
        printf("Unknown command\n");
    }
}
```

**После:**
```c
void handleCommand(int cmd) {
    switch (cmd) {
        case 1: start(); break;
        case 2: stop(); break;
        case 3: pause(); break;
        default: printf("Unknown command\n");
    }
}
```

**Описание:** Замена цепочки условий на switch улучшает читаемость.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 6/10
- Производительность: 3/10
- Безопасность: 5/10
- Надежность: 6/10

## 4. Устранение дублирования кода

**До:**
```c
void printUserInfo(User *user) {
    printf("Name: %s\n", user->name);
    printf("Age: %d\n", user->age);
    printf("Email: %s\n", user->email);
}

void printAdminInfo(Admin *admin) {
    printf("Name: %s\n", admin->name);
    printf("Age: %d\n", admin->age);
    printf("Email: %s\n", admin->email);
    printf("Access level: %d\n", admin->accessLevel);
}
```

**После:**
```c
void printPersonInfo(const char *name, int age, const char *email) {
    printf("Name: %s\n", name);
    printf("Age: %d\n", age);
    printf("Email: %s\n", email);
}

void printUserInfo(User *user) {
    printPersonInfo(user->name, user->age, user->email);
}

void printAdminInfo(Admin *admin) {
    printPersonInfo(admin->name, admin->age, admin->email);
    printf("Access level: %d\n", admin->accessLevel);
}
```

**Описание:** Устранение дублированного кода путем выделения общей части.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 6/10
- Надежность: 7/10

## 5. Замена #define на enum для связанных констант

**До:**
```c
#define STATUS_OK 0
#define STATUS_ERROR 1
#define STATUS_WARNING 2
```

**После:**
```c
typedef enum {
    STATUS_OK = 0,
    STATUS_ERROR,
    STATUS_WARNING
} StatusCode;
```

**Описание:** Enum обеспечивает лучшую типизацию и автодополнение в IDE.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 7/10
- Надежность: 8/10

## 6. Инкапсуляция работы с указателями

**До:**
```c
void processData(int *data, int size) {
    for (int i = 0; i < size; i++) {
        data[i] *= 2;
    }
}
```

**После:**
```c
typedef struct {
    int *data;
    int size;
} IntArray;

void processIntArray(IntArray *arr) {
    for (int i = 0; i < arr->size; i++) {
        arr->data[i] *= 2;
    }
}
```

**Описание:** Инкапсуляция указателя и размера в структуру уменьшает вероятность ошибок.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 9/10
- Производительность: 2/10
- Безопасность: 8/10
- Надежность: 9/10

## 7. Замена malloc/free на специализированные функции

**До:**
```c
User *createUser() {
    User *user = malloc(sizeof(User));
    // инициализация
    return user;
}

void someFunction() {
    User *user = createUser();
    // использование
    free(user);
}
```

**После:**
```c
User *createUser() {
    User *user = malloc(sizeof(User));
    if (user == NULL) return NULL;
    
    memset(user, 0, sizeof(User)); // безопасная инициализация
    return user;
}

void deleteUser(User *user) {
    if (user != NULL) {
        free(user->name); // освобождение вложенных ресурсов
        free(user->email);
        free(user);
    }
}

void someFunction() {
    User *user = createUser();
    if (user == NULL) return;
    
    // использование
    deleteUser(user);
}
```

**Описание:** Более безопасное управление памятью с проверками и очисткой.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 8/10
- Производительность: 3/10
- Безопасность: 9/10
- Надежность: 9/10

## 8. Введение буферизации для частых операций ввода-вывода

**До:**
```c
void writeLog(const char *message) {
    FILE *file = fopen("app.log", "a");
    if (file) {
        fprintf(file, "%s\n", message);
        fclose(file);
    }
}
```

**После:**
```c
static FILE *logFile = NULL;

void initLogger() {
    logFile = fopen("app.log", "a");
}

void writeLog(const char *message) {
    if (logFile) {
        fprintf(logFile, "%s\n", message);
        fflush(logFile);
    }
}

void closeLogger() {
    if (logFile) {
        fclose(logFile);
        logFile = NULL;
    }
}
```

**Описание:** Буферизация уменьшает количество операций открытия/закрытия файла.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 5/10
- Надежность: 6/10

## 9. Замена индексов массива на указатели

**До:**
```c
void sumArray(int *arr, int size, int *result) {
    *result = 0;
    for (int i = 0; i < size; i++) {
        *result += arr[i];
    }
}
```

**После:**
```c
void sumArray(int *arr, int size, int *result) {
    *result = 0;
    int *end = arr + size;
    for (int *p = arr; p < end; p++) {
        *result += *p;
    }
}
```

**Описание:** Использование указателей может быть более эффективным на некоторых архитектурах.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 5/10
- Производительность: 7/10
- Безопасность: 5/10
- Надежность: 6/10

## 10. Введение проверки ошибок вместо молчаливого игнорирования

**До:**
```c
int divide(int a, int b) {
    return a / b;
}
```

**После:**
```c
bool divide(int a, int b, int *result) {
    if (b == 0) {
        return false;
    }
    *result = a / b;
    return true;
}
```

**Описание:** Явная обработка ошибок делает код надежнее.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 7/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 11. Замена глобальных переменных на передачу параметров

**До:**
```c
int globalCounter;

void incrementCounter() {
    globalCounter++;
}

void printCounter() {
    printf("%d\n", globalCounter);
}
```

**После:**
```c
void incrementCounter(int *counter) {
    (*counter)++;
}

void printCounter(int counter) {
    printf("%d\n", counter);
}
```

**Описание:** Устранение глобальных переменных улучшает модульность.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 9/10
- Производительность: 2/10
- Безопасность: 8/10
- Надежность: 8/10

## 12. Использование const для неизменяемых параметров

**До:**
```c
void printString(char *str) {
    printf("%s\n", str);
}
```

**После:**
```c
void printString(const char *str) {
    printf("%s\n", str);
}
```

**Описание:** Const помогает обнаружить ошибки на этапе компиляции.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 7/10
- Производительность: 3/10
- Безопасность: 8/10
- Надежность: 8/10

## 13. Введение структуры для группировки связанных данных

**До:**
```c
void drawRectangle(int x, int y, int width, int height, int color) {
    // рисуем прямоугольник
}
```

**После:**
```c
typedef struct {
    int x, y;
    int width, height;
} Rectangle;

typedef struct {
    unsigned char r, g, b;
} Color;

void drawRectangle(Rectangle rect, Color color) {
    // рисуем прямоугольник
}
```

**Описание:** Группировка связанных данных улучшает читаемость.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 9/10
- Производительность: 2/10
- Безопасность: 7/10
- Надежность: 8/10

## 14. Оптимизация вложенных циклов

**До:**
```c
for (int i = 0; i < 1000; i++) {
    for (int j = 0; j < 1000; j++) {
        process(matrix[i][j]);
    }
}
```

**После:**
```c
for (int i = 0; i < 1000; i++) {
    int *row = matrix[i];
    for (int j = 0; j < 1000; j++) {
        process(row[j]);
    }
}
```

**Описание:** Уменьшение количества вычислений адресов элементов.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 5/10
- Производительность: 8/10
- Безопасность: 5/10
- Надежность: 6/10

## 15. Замена рекурсии на итерацию

**До:**
```c
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

**После:**
```c
int factorial(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

**Описание:** Итеративная версия избегает переполнения стека.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 8/10

## 16. Использование memcpy вместо поэлементного копирования

**До:**
```c
void copyArray(int *dest, int *src, int size) {
    for (int i = 0; i < size; i++) {
        dest[i] = src[i];
    }
}
```

**После:**
```c
void copyArray(int *dest, int *src, int size) {
    memcpy(dest, src, size * sizeof(int));
}
```

**Описание:** Использование оптимизированных библиотечных функций.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 5/10
- Производительность: 9/10
- Безопасность: 6/10
- Надежность: 7/10

## 17. Введение проверки границ массива

**До:**
```c
int getElement(int *array, int index) {
    return array[index];
}
```

**После:**
```c
bool getElement(int *array, int size, int index, int *result) {
    if (index < 0 || index >= size) {
        return false;
    }
    *result = array[index];
    return true;
}
```

**Описание:** Защита от выхода за границы массива.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 7/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 18. Замена sprintf на snprintf

**До:**
```c
void formatMessage(char *buffer, const char *name) {
    sprintf(buffer, "Hello, %s!", name);
}
```

**После:**
```c
void formatMessage(char *buffer, size_t size, const char *name) {
    snprintf(buffer, size, "Hello, %s!", name);
}
```

**Описание:** Защита от переполнения буфера.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 6/10
- Производительность: 3/10
- Безопасность: 9/10
- Надежность: 9/10

## 19. Вынос условий в отдельные функции

**До:**
```c
if (user->age > 18 && user->age < 65 && user->status == ACTIVE) {
    // ...
}
```

**После:**
```c
bool isEligibleForDiscount(const User *user) {
    return user->age > 18 && user->age < 65 && user->status == ACTIVE;
}

// Использование:
if (isEligibleForDiscount(user)) {
    // ...
}
```

**Описание:** Улучшение читаемости сложных условий.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 6/10
- Надежность: 7/10

## 20. Замена макросов на inline-функции

**До:**
```c
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

**После:**
```c
static inline int max(int a, int b) {
    return a > b ? a : b;
}
```

**Описание:** Inline-функции безопаснее макросов с точки зрения типов.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 8/10
- Надежность: 8/10

## 21. Использование union для экономии памяти

**До:**
```c
struct Variant {
    int type;
    int intValue;
    double doubleValue;
    char *stringValue;
};
```

**После:**
```c
struct Variant {
    int type;
    union {
        int intValue;
        double doubleValue;
        char *stringValue;
    } value;
};
```

**Описание:** Экономия памяти при хранении вариантных типов.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 7/10
- Безопасность: 5/10
- Надежность: 6/10

## 22. Введение обработчика ошибок вместо множества проверок

**До:**
```c
int processFile(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) return -1;
    
    char buffer[256];
    if (!fgets(buffer, sizeof(buffer), file)) {
        fclose(file);
        return -2;
    }
    
    // обработка
    
    fclose(file);
    return 0;
}
```

**После:**
```c
typedef enum {
    FILE_OK,
    FILE_OPEN_ERROR,
    FILE_READ_ERROR
} FileStatus;

FileStatus processFile(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) return FILE_OPEN_ERROR;
    
    char buffer[256];
    if (!fgets(buffer, sizeof(buffer), file)) {
        fclose(file);
        return FILE_READ_ERROR;
    }
    
    // обработка
    
    fclose(file);
    return FILE_OK;
}
```

**Описание:** Более четкая система обработки ошибок.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 8/10
- Надежность: 8/10

## 23. Оптимизация работы со строками

**До:**
```c
char fullName[100];
strcpy(fullName, firstName);
strcat(fullName, " ");
strcat(fullName, lastName);
```

**После:**
```c
char fullName[100];
snprintf(fullName, sizeof(fullName), "%s %s", firstName, lastName);
```

**Описание:** Однократная операция вместо нескольких конкатенаций.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 8/10

## 24. Замена ручного управления памятью на автоматические буферы

**До:**
```c
char *createGreeting(const char *name) {
    char *greeting = malloc(strlen(name) + 8);
    if (greeting) {
        strcpy(greeting, "Hello, ");
        strcat(greeting, name);
        strcat(greeting, "!");
    }
    return greeting;
}
```

**После:**
```c
void createGreeting(const char *name, char *buffer, size_t size) {
    snprintf(buffer, size, "Hello, %s!", name);
}
```

**Описание:** Передача буфера в функцию вместо выделения памяти.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 8/10

## 25. Введение типа bool вместо int для логических значений

**До:**
```c
int isValid(const char *input) {
    return strlen(input) > 0;
}
```

**После:**
```c
#include <stdbool.h>

bool isValid(const char *input) {
    return strlen(input) > 0;
}
```

**Описание:** Более четкое выражение намерений через тип bool.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 7/10
- Надежность: 8/10

## 26. Использование static для скрытия внутренних функций

**До:**
```c
void helperFunction() {
    // ...
}

void publicFunction() {
    helperFunction();
}
```

**После:**
```c
static void helperFunction() {
    // ...
}

void publicFunction() {
    helperFunction();
}
```

**Описание:** Сокрытие внутренних функций от внешнего доступа.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 7/10
- Надежность: 7/10

## 27. Замена goto на структурированные конструкции

**До:**
```c
int process() {
    if (step1() != 0) goto error;
    if (step2() != 0) goto error;
    if (step3() != 0) goto error;
    
    return 0;
    
error:
    cleanup();
    return -1;
}
```

**После:**
```c
int process() {
    if (step1() != 0) {
        cleanup();
        return -1;
    }
    if (step2() != 0) {
        cleanup();
        return -1;
    }
    if (step3() != 0) {
        cleanup();
        return -1;
    }
    
    return 0;
}
```

**Описание:** Избегание goto в пользу структурированного кода.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 7/10
- Производительность: 2/10
- Безопасность: 6/10
- Надежность: 7/10

## 28. Введение мьютексов для потокобезопасности

**До:**
```c
int counter = 0;

void increment() {
    counter++;
}
```

**После:**
```c
#include <pthread.h>

int counter = 0;
pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

void increment() {
    pthread_mutex_lock(&counter_mutex);
    counter++;
    pthread_mutex_unlock(&counter_mutex);
}
```

**Описание:** Добавление защиты для многопоточной среды.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 7/10
- Производительность: 4/10
- Безопасность: 9/10
- Надежность: 9/10

## 29. Замена ручного управления ресурсами на RAII-подобный подход

**До:**
```c
void processFile() {
    FILE *file = fopen("data.txt", "r");
    if (!file) return;
    
    // обработка файла
    
    fclose(file);
}
```

**После:**
```c
typedef struct {
    FILE *file;
} FileHandle;

FileHandle openFile(const char *filename) {
    FileHandle fh = { fopen(filename, "r") };
    return fh;
}

void closeFile(FileHandle *fh) {
    if (fh->file) {
        fclose(fh->file);
        fh->file = NULL;
    }
}

void processFile() {
    FileHandle fh = openFile("data.txt");
    if (!fh.file) return;
    
    // обработка файла
    
    closeFile(&fh);
}
```

**Описание:** Более безопасное управление ресурсами.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 8/10
- Производительность: 3/10
- Безопасность: 9/10
- Надежность: 9/10

## 30. Использование битовых полей вместо ручных операций

**До:**
```c
unsigned int flags;

#define FLAG_A 0x01
#define FLAG_B 0x02
#define FLAG_C 0x04

void setFlags() {
    flags |= FLAG_A;
    flags &= ~FLAG_B;
}
```

**После:**
```c
typedef struct {
    unsigned int flag_a : 1;
    unsigned int flag_b : 1;
    unsigned int flag_c : 1;
} Flags;

void setFlags(Flags *flags) {
    flags->flag_a = 1;
    flags->flag_b = 0;
}
```

**Описание:** Более читаемое определение и использование флагов.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 7/10
- Надежность: 8/10

Продолжаю серию примеров рефакторинга на языке Си с оценками по указанным критериям.

## 31. Замена ручного копирования структур на присваивание

**До:**
```c
struct Point {
    int x;
    int y;
};

void copyPoint(struct Point *dest, struct Point *src) {
    dest->x = src->x;
    dest->y = src->y;
}
```

**После:**
```c
typedef struct {
    int x;
    int y;
} Point;

void copyPoint(Point *dest, const Point *src) {
    *dest = *src; // Побитовое копирование
}
```

**Описание:** Использование встроенного присваивания структур вместо ручного копирования полей.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 6/10
- Надежность: 7/10

## 32. Вынос вычислений из циклов

**До:**
```c
for (int i = 0; i < strlen(str); i++) {
    // обработка символов
}
```

**После:**
```c
size_t len = strlen(str);
for (size_t i = 0; i < len; i++) {
    // обработка символов
}
```

**Описание:** Избегание повторного вычисления длины строки на каждой итерации.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 33. Использование префиксного инкремента

**До:**
```c
for (int i = 0; i < n; i++) {
    // ...
}
```

**После:**
```c
for (int i = 0; i < n; ++i) {
    // ...
}
```

**Описание:** Префиксный инкремент может быть эффективнее для сложных типов.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 4/10
- Производительность: 5/10
- Безопасность: 5/10
- Надежность: 5/10

## 34. Замена rand() на более надежный ГПСЧ

**До:**
```c
int randomNum = rand() % 100;
```

**После:**
```c
#include <time.h>
#include <stdlib.h>

void initRandom() {
    srand(time(NULL));
}

int randomNum = rand() / (RAND_MAX / 100 + 1);
```

**Описание:** Более равномерное распределение случайных чисел.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 6/10
- Производительность: 4/10
- Безопасность: 7/10
- Надежность: 8/10

## 35. Оптимизация работы с памятью через calloc

**До:**
```c
int *arr = malloc(size * sizeof(int));
memset(arr, 0, size * sizeof(int));
```

**После:**
```c
int *arr = calloc(size, sizeof(int));
```

**Описание:** calloc одновременно выделяет и обнуляет память.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 7/10
- Надежность: 7/10

## 36. Введение typedef для сложных указателей

**До:**
```c
int (**funcPtrArray)(double);
```

**После:**
```c
typedef int (*FuncPtr)(double);
FuncPtr *funcPtrArray;
```

**Описание:** Упрощение сложных объявлений указателей.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 6/10
- Надежность: 7/10

## 37. Замена void* на типизированные указатели

**До:**
```c
void processData(void *data, int type) {
    if (type == 0) {
        int *i = (int*)data;
        // ...
    }
}
```

**После:**
```c
typedef enum {
    INT_TYPE,
    DOUBLE_TYPE
} DataType;

void processInt(int *data) { /* ... */ }

void processData(void *data, DataType type) {
    switch(type) {
        case INT_TYPE: processInt(data); break;
        // ...
    }
}
```

**Описание:** Более безопасная работа с разными типами данных.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 8/10
- Производительность: 4/10
- Безопасность: 8/10
- Надежность: 8/10

## 38. Использование restrict для указателей

**До:**
```c
void addArrays(int *a, int *b, int *c, int size) {
    for (int i = 0; i < size; i++) {
        c[i] = a[i] + b[i];
    }
}
```

**После:**
```c
void addArrays(int *restrict a, int *restrict b, int *restrict c, int size) {
    for (int i = 0; i < size; i++) {
        c[i] = a[i] + b[i];
    }
}
```

**Описание:** Подсказка компилятору об отсутствии алиасинга.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 5/10
- Производительность: 7/10
- Безопасность: 5/10
- Надежность: 6/10

## 39. Замена ручного управления памятью на стек

**До:**
```c
int *createArray(int size) {
    return malloc(size * sizeof(int));
}
```

**После:**
```c
void processArray(int size) {
    int array[size]; // VLA (C99)
    // ...
}
```

**Описание:** Использование автоматической памяти вместо кучи.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 7/10
- Надежность: 7/10

## 40. Введение обработки сигналов

**До:**
```c
while(1) {
    // бесконечный цикл
}
```

**После:**
```c
#include <signal.h>

volatile sig_atomic_t keepRunning = 1;

void handleInterrupt(int sig) {
    keepRunning = 0;
}

int main() {
    signal(SIGINT, handleInterrupt);
    
    while(keepRunning) {
        // цикл с возможностью прерывания
    }
}
```

**Описание:** Корректная обработка прерываний программы.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 7/10
- Производительность: 4/10
- Безопасность: 9/10
- Надежность: 9/10

## 41. Использование _Generic для type-safe операций

**До:**
```c
void printInt(int x) { printf("%d", x); }
void printDouble(double x) { printf("%f", x); }
```

**После:**
```c
#define print(x) _Generic((x), \
    int: printInt, \
    double: printDouble \
)(x)
```

**Описание:** Type-safe макросы с выбором реализации по типу.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 8/10
- Производительность: 5/10
- Безопасность: 8/10
- Надежность: 8/10

## 42. Замена #define на static const

**До:**
```c
#define MAX_SIZE 100
```

**После:**
```c
static const int MAX_SIZE = 100;
```

**Описание:** Более современный и безопасный способ определения констант.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 7/10
- Производительность: 3/10
- Безопасность: 7/10
- Надежность: 8/10

## 43. Оптимизация условных выражений

**До:**
```c
if (x > 0 && x < 10 && y > 0 && y < 10) { ... }
```

**После:**
```c
#define IN_RANGE(val, min, max) ((val) >= (min) && (val) <= (max))

if (IN_RANGE(x, 1, 9) && IN_RANGE(y, 1, 9)) { ... }
```

**Описание:** Улучшение читаемости сложных условий.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 7/10
- Производительность: 4/10
- Безопасность: 6/10
- Надежность: 7/10

## 44. Использование union для type punning

**До:**
```c
float f = 3.14f;
unsigned u = *(unsigned*)&f; // Небезопасно
```

**После:**
```c
typedef union {
    float f;
    unsigned u;
} FloatPun;

FloatPun pun = { .f = 3.14f };
unsigned u = pun.u;
```

**Описание:** Безопасное преобразование типов через union.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 8/10
- Надежность: 8/10

## 45. Введение compile-time проверок

**До:**
```c
struct Header {
    int version;
    // ...
};
```

**После:**
```c
struct Header {
    int version;
    // ...
};

static_assert(sizeof(struct Header) == 16, "Header size mismatch");
```

**Описание:** Проверка предположений на этапе компиляции.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 46. Замена самописных контейнеров на библиотечные

**До:**
```c
typedef struct {
    int *data;
    int size;
    int capacity;
} IntVector;

// + множество функций для работы
```

**После:**
```c
#include <uthash.h>

typedef struct {
    int key;
    int value;
    UT_hash_handle hh;
} IntHash;
```

**Описание:** Использование проверенных библиотек вместо самописных решений.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 9/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 9/10

## 47. Введение unit-тестов для рефакторинга

**До:**
```c
// Код без тестов
```

**После:**
```c
#include <assert.h>

void testFunction() {
    assert(calculateSomething(2) == 4);
}

int main() {
    testFunction();
    return 0;
}
```

**Описание:** Обеспечение сохранения функциональности после изменений.

**Оценки:**
- Оптимизация: 2/10
- Архитектура: 9/10
- Производительность: 1/10
- Безопасность: 8/10
- Надежность: 9/10

## 48. Использование attribute для оптимизации

**До:**
```c
void processData() { ... }
```

**После:**
```c
__attribute__((hot)) void processData() { ... }
```

**Описание:** Подсказки компилятору для оптимизации.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 5/10
- Производительность: 8/10
- Безопасность: 4/10
- Надежность: 5/10

## 49. Замена ручного парсинга на sscanf

**До:**
```c
int day, month, year;
char *p = dateStr;
day = atoi(p);
while (*p && *p != '/') p++;
month = atoi(++p);
while (*p && *p != '/') p++;
year = atoi(++p);
```

**После:**
```c
int day, month, year;
sscanf(dateStr, "%d/%d/%d", &day, &month, &year);
```

**Описание:** Использование стандартных функций для парсинга.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 7/10
- Надежность: 8/10

## 50. Введение compile-time вычислений

**До:**
```c
int factorial(int n) { ... }

int x = factorial(5);
```

**После:**
```c
#define FACTORIAL(n) (n <= 1 ? 1 : n * FACTORIAL(n-1))

int x = FACTORIAL(5); // Вычисляется на этапе компиляции
```

**Описание:** Перенос вычислений на этап компиляции.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 6/10
- Производительность: 9/10
- Безопасность: 5/10
- Надежность: 6/10

## 51. Использование thread-local storage

**До:**
```c
int counter; // Глобальная переменная

void increment() {
    counter++; // Проблемы в многопоточной среде
}
```

**После:**
```c
_Thread_local int counter; // TLS переменная

void increment() {
    counter++; // Теперь потокобезопасно
}
```

**Описание:** Изоляция данных между потоками.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 8/10
- Производительность: 7/10
- Безопасность: 9/10
- Надежность: 9/10

## 52. Замена ручного управления памятью на пулы

**До:**
```c
void *createObject() {
    return malloc(sizeof(Object));
}
```

**После:**
```c
ObjectPool pool;

void initPool() {
    pool = createObjectPool(100);
}

void *createObject() {
    return getObjectFromPool(&pool);
}
```

**Описание:** Уменьшение накладных расходов на выделение памяти.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 53. Использование битовых операций вместо арифметики

**До:**
```c
int isEven(int x) {
    return x % 2 == 0;
}
```

**После:**
```c
int isEven(int x) {
    return (x & 1) == 0;
}
```

**Описание:** Более эффективная проверка четности.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 5/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 54. Введение compile-time хеширования строк

**До:**
```c
if (strcmp(command, "start") == 0) { ... }
```

**После:**
```c
#define HASH(s) ((s[0] << 8) | s[1])

switch (HASH(command)) {
    case HASH("start"): ... break;
    // ...
}
```

**Описание:** Быстрое сравнение строк через хеши.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 6/10
- Производительность: 9/10
- Безопасность: 5/10
- Надежность: 6/10

## 55. Использование atomic операций

**До:**
```c
int counter = 0;

void increment() {
    counter++; // Не потокобезопасно
}
```

**После:**
```c
#include <stdatomic.h>

atomic_int counter = 0;

void increment() {
    atomic_fetch_add(&counter, 1);
}
```

**Описание:** Потокобезопасные атомарные операции.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 8/10
- Производительность: 7/10
- Безопасность: 9/10
- Надежность: 9/10

## 56. Замена ручного форматирования на asprintf

**До:**
```c
char *createMessage(const char *name) {
    char *msg = malloc(strlen(name) + 20);
    sprintf(msg, "Hello, %s!", name);
    return msg;
}
```

**После:**
```c
char *createMessage(const char *name) {
    char *msg;
    asprintf(&msg, "Hello, %s!", name);
    return msg;
}
```

**Описание:** Безопасное динамическое форматирование строк.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 8/10
- Надежность: 8/10

## 57. Введение compile-time assert'ов

**До:**
```c
// Проверки только в runtime
```

**После:**
```c
#define COMPILE_TIME_ASSERT(expr) typedef char static_assertion[(expr) ? 1 : -1]

COMPILE_TIME_ASSERT(sizeof(int) == 4);
```

**Описание:** Проверка предположений на этапе компиляции.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 58. Использование flexible array members

**До:**
```c
struct Data {
    int size;
    char *buffer;
};

Data *createData(int size) {
    Data *d = malloc(sizeof(Data));
    d->buffer = malloc(size);
    return d;
}
```

**После:**
```c
struct Data {
    int size;
    char buffer[];
};

Data *createData(int size) {
    Data *d = malloc(sizeof(Data) + size);
    d->size = size;
    return d;
}
```

**Описание:** Более эффективное хранение данных переменной длины.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 7/10
- Надежность: 8/10

## 59. Введение compile-time таблиц

**До:**
```c
int getDayCount(int month) {
    static const int days[] = {31,28,31,...};
    return days[month-1];
}
```

**После:**
```c
#define DAYS_IN_MONTH(month) \
    ((month) == 2 ? 28 : \
    ((month) == 4 || (month) == 6 || (month) == 9 || (month) == 11) ? 30 : 31)

int getDayCount(int month) {
    return DAYS_IN_MONTH(month);
}
```

**Описание:** Перенос таблицы на этап компиляции.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 60. Использование designated initializers

**До:**
```c
struct Point {
    int x;
    int y;
    int z;
};

struct Point p = {0, 0, 0};
```

**После:**
```c
struct Point {
    int x;
    int y;
    int z;
};

struct Point p = {
    .x = 0,
    .y = 0,
    .z = 0
};
```

**Описание:** Более читаемая инициализация структур.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 2/10
- Безопасность: 7/10
- Надежность: 8/10

---

Продолжаю серию примеров рефакторинга на языке Си с оценками по пяти критериям.

## 61. Замена ручного управления состоянием на FSM

**До:**
```c
int state = 0;
void process() {
    if (state == 0) {
        // действие 1
        state = 1;
    } else if (state == 1) {
        // действие 2
        state = 2;
    }
    // ...
}
```

**После:**
```c
typedef void (*StateHandler)(void*);

typedef struct {
    StateHandler handler;
} StateMachine;

void state1(void* ctx);
void state2(void* ctx);

StateMachine machine = {state1};

void process(StateMachine* sm, void* ctx) {
    sm->handler(ctx);
}
```

**Описание:** Четкое разделение состояний с помощью конечного автомата.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 9/10
- Производительность: 5/10
- Безопасность: 7/10
- Надежность: 8/10

## 62. Использование указателей на функции вместо switch

**До:**
```c
void processCommand(char cmd) {
    switch(cmd) {
        case 'A': actionA(); break;
        case 'B': actionB(); break;
        // ...
    }
}
```

**После:**
```c
typedef void (*CommandHandler)(void);

typedef struct {
    char cmd;
    CommandHandler handler;
} CommandEntry;

CommandEntry commands[] = {
    {'A', actionA},
    {'B', actionB},
    // ...
};

void processCommand(char cmd) {
    for (size_t i = 0; i < sizeof(commands)/sizeof(commands[0]); i++) {
        if (commands[i].cmd == cmd) {
            commands[i].handler();
            return;
        }
    }
}
```

**Описание:** Более гибкая система обработки команд.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 8/10
- Производительность: 6/10
- Безопасность: 7/10
- Надежность: 8/10

## 63. Введение кэширования для тяжелых вычислений

**До:**
```c
double calculateExpensive(int x) {
    // сложные вычисления
    return result;
}
```

**После:**
```c
typedef struct {
    int key;
    double value;
} CacheEntry;

CacheEntry *cache = NULL;

double calculateExpensive(int x) {
    CacheEntry *entry;
    HASH_FIND_INT(cache, &x, entry);
    if (entry) return entry->value;
    
    double result = /* сложные вычисления */;
    
    entry = malloc(sizeof(CacheEntry));
    entry->key = x;
    entry->value = result;
    HASH_ADD_INT(cache, key, entry);
    
    return result;
}
```

**Описание:** Ускорение работы за счет кэширования результатов.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 7/10
- Производительность: 9/10
- Безопасность: 6/10
- Надежность: 7/10

## 64. Замена ручного парсинга на strtok_r

**До:**
```c
char *token = strtok(str, ",");
while (token) {
    // обработка
    token = strtok(NULL, ",");
}
```

**После:**
```c
char *saveptr;
char *token = strtok_r(str, ",", &saveptr);
while (token) {
    // обработка
    token = strtok_r(NULL, ",", &saveptr);
}
```

**Описание:** Потокобезопасная версия strtok.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 6/10
- Производительность: 5/10
- Безопасность: 8/10
- Надежность: 8/10

## 65. Введение object pool для частых аллокаций

**До:**
```c
Object* createObject() {
    return malloc(sizeof(Object));
}

void freeObject(Object* obj) {
    free(obj);
}
```

**После:**
```c
typedef struct {
    Object *pool;
    size_t size;
} ObjectPool;

ObjectPool pool = {NULL, 0};

Object* getObject() {
    if (!pool.size) {
        pool.pool = malloc(100 * sizeof(Object));
        pool.size = 100;
    }
    return &pool.pool[--pool.size];
}

void releaseObject(Object* obj) {
    pool.pool[pool.size++] = *obj;
}
```

**Описание:** Снижение накладных расходов на аллокацию.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 66. Использование битовых полей для флагов

**До:**
```c
#define FLAG_A 0x01
#define FLAG_B 0x02
#define FLAG_C 0x04

unsigned flags;

void setFlags() {
    flags |= FLAG_A;
    flags &= ~FLAG_B;
}
```

**После:**
```c
typedef struct {
    unsigned a : 1;
    unsigned b : 1;
    unsigned c : 1;
} Flags;

Flags flags;

void setFlags() {
    flags.a = 1;
    flags.b = 0;
}
```

**Описание:** Более структурированное хранение флагов.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 8/10
- Производительность: 7/10
- Безопасность: 7/10
- Надежность: 8/10

## 67. Введение arena allocator

**До:**
```c
void process() {
    Object *o1 = malloc(sizeof(Object));
    Object *o2 = malloc(sizeof(Object));
    // ...
    free(o1);
    free(o2);
}
```

**После:**
```c
typedef struct {
    char *memory;
    size_t size;
    size_t used;
} Arena;

Arena createArena(size_t size) {
    Arena a = {malloc(size), size, 0};
    return a;
}

void* arenaAlloc(Arena *a, size_t size) {
    if (a->used + size > a->size) return NULL;
    void *ptr = a->memory + a->used;
    a->used += size;
    return ptr;
}

void freeArena(Arena *a) {
    free(a->memory);
    a->memory = NULL;
    a->used = a->size = 0;
}
```

**Описание:** Оптимизация частых аллокаций/освобождений.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 8/10
- Производительность: 9/10
- Безопасность: 6/10
- Надежность: 7/10

## 68. Замена rand() на PCG

**До:**
```c
int r = rand() % 100;
```

**После:**
```c
#include "pcg_basic.h"

pcg32_random_t rng;

void initRNG() {
    pcg32_srandom(time(NULL), (intptr_t)&rng);
}

int r = pcg32_boundedrand(&rng, 100);
```

**Описание:** Использование более качественного ГПСЧ.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 7/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 8/10

## 69. Введение compile-time строк

**До:**
```c
const char *str = "Hello";
size_t len = strlen(str);
```

**После:**
```c
#define STR_HELLO "Hello"
#define STRLEN(s) (sizeof(s)/sizeof(s[0]) - 1)

const char str[] = STR_HELLO;
size_t len = STRLEN(str); // вычисляется на этапе компиляции
```

**Описание:** Избегание runtime вычислений длины строк.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 7/10
- Надежность: 7/10

## 70. Использование _Alignas для выравнивания

**До:**
```c
struct Data {
    char c;
    double d; // возможны проблемы с выравниванием
};
```

**После:**
```c
struct Data {
    char c;
    _Alignas(8) double d; // гарантированное выравнивание
};
```

**Описание:** Явное указание требований к выравниванию.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 7/10
- Надежность: 8/10

## 71. Введение tagged union

**До:**
```c
struct Node {
    int type;
    void *data;
};
```

**После:**
```c
typedef struct {
    int type;
    union {
        int i;
        double d;
        char *s;
    } data;
} Node;
```

**Описание:** Более безопасное хранение вариантных данных.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 8/10
- Производительность: 6/10
- Безопасность: 8/10
- Надежность: 8/10

## 72. Замена atoi на strtol

**До:**
```c
int num = atoi(str);
```

**После:**
```c
char *end;
long num = strtol(str, &end, 10);
if (end == str || *end != '\0' || errno == ERANGE) {
    // обработка ошибки
}
```

**Описание:** Более безопасное преобразование строк в числа.

**Оценки:**
- Оптимизация: 4/10
- Архитектура: 7/10
- Производительность: 4/10
- Безопасность: 9/10
- Надежность: 9/10

## 73. Использование restrict для матриц

**До:**
```c
void matmul(double *a, double *b, double *c, int n) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int k = 0; k < n; k++)
                c[i*n+j] += a[i*n+k] * b[k*n+j];
}
```

**После:**
```c
void matmul(double *restrict a, double *restrict b, 
           double *restrict c, int n) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int k = 0; k < n; k++)
                c[i*n+j] += a[i*n+k] * b[k*n+j];
}
```

**Описание:** Подсказка компилятору об отсутствии алиасинга.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 5/10
- Надежность: 6/10

## 74. Введение compile-time вычисления CRC

**До:**
```c
unsigned computeCRC(const char *s) {
    // вычисление CRC в runtime
}
```

**После:**
```c
#define CRC32_POLY 0xEDB88320
#define CRC32(crc, ch) (crc = (crc >> 8) ^ crc_table[(crc ^ (ch)) & 0xff])

static const unsigned crc_table[256] = {
    // таблица, вычисленная на этапе компиляции
};

unsigned computeCRC(const char *s) {
    unsigned crc = ~0U;
    while (*s) CRC32(crc, *s++);
    return crc ^ ~0U;
}
```

**Описание:** Перенос части вычислений на этап компиляции.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 75. Использование _Generic для type-safe printf

**До:**
```c
void printInt(int x) { printf("%d", x); }
void printDouble(double x) { printf("%f", x); }
// ...
```

**После:**
```c
#define print(x) _Generic((x), \
    int: printf("%d", x), \
    double: printf("%f", x), \
    char*: printf("%s", x) \
)
```

**Описание:** Type-safe вывод разных типов.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 8/10
- Производительность: 5/10
- Безопасность: 8/10
- Надежность: 8/10

## 76. Введение compile-time хеширования

**До:**
```c
if (!strcmp(str, "long_command_name")) { ... }
```

**После:**
```c
#define HASH(s) (s[0] + s[1] * 256 + s[2] * 65536)

switch (HASH(str)) {
    case HASH("cmd"): /* ... */ break;
    // ...
}
```

**Описание:** Быстрое сравнение строк через хеши.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 6/10
- Производительность: 9/10
- Безопасность: 5/10
- Надежность: 6/10

## 77. Использование atomic для счетчиков

**До:**
```c
int counter = 0;

void inc() {
    counter++;
}
```

**После:**
```c
#include <stdatomic.h>

atomic_int counter = 0;

void inc() {
    atomic_fetch_add(&counter, 1);
}
```

**Описание:** Потокобезопасные операции с счетчиком.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 8/10
- Производительность: 7/10
- Безопасность: 9/10
- Надежность: 9/10

## 78. Введение memory pool для структур

**До:**
```c
typedef struct {
    // поля
} Obj;

Obj *createObj() { return malloc(sizeof(Obj)); }
void freeObj(Obj *o) { free(o); }
```

**После:**
```c
typedef struct {
    Obj *freeList;
} ObjPool;

ObjPool pool = {NULL};

Obj *createObj() {
    if (!pool.freeList) {
        Obj *block = malloc(100 * sizeof(Obj));
        for (int i = 0; i < 99; i++)
            block[i].next = &block[i+1];
        pool.freeList = block;
    }
    Obj *o = pool.freeList;
    pool.freeList = o->next;
    return o;
}

void freeObj(Obj *o) {
    o->next = pool.freeList;
    pool.freeList = o;
}
```

**Описание:** Уменьшение фрагментации памяти.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 79. Использование qsort_r вместо qsort

**До:**
```c
int compare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void sort(int *arr, size_t n) {
    qsort(arr, n, sizeof(int), compare);
}
```

**После:**
```c
int compare(const void *a, const void *b, void *arg) {
    return *(int*)a - *(int*)b;
}

void sort(int *arr, size_t n) {
    qsort_r(arr, n, sizeof(int), compare, NULL);
}
```

**Описание:** Более гибкая сортировка с передачей контекста.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 7/10
- Производительность: 6/10
- Безопасность: 7/10
- Надежность: 7/10

## 80. Введение slab allocator

**До:**
```c
typedef struct {
    // ...
} Item;

Item *createItem() { return malloc(sizeof(Item)); }
void freeItem(Item *i) { free(i); }
```

**После:**
```c
typedef struct {
    Item *slabs;
    Item *freeList;
} ItemAllocator;

ItemAllocator allocator = {NULL, NULL};

Item *createItem() {
    if (!allocator.freeList) {
        Item *slab = malloc(4096);
        // инициализация freeList в slab
    }
    Item *i = allocator.freeList;
    allocator.freeList = i->next;
    return i;
}

void freeItem(Item *i) {
    i->next = allocator.freeList;
    allocator.freeList = i;
}
```

**Описание:** Оптимизация частых аллокаций мелких объектов.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 8/10
- Производительность: 9/10
- Безопасность: 6/10
- Надежность: 7/10

## 81. Использование _Static_assert

**До:**
```c
assert(sizeof(int) == 4);
```

**После:**
```c
_Static_assert(sizeof(int) == 4, "int must be 4 bytes");
```

**Описание:** Проверка на этапе компиляции.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 82. Введение memory arena для временных объектов

**До:**
```c
void process() {
    char *tmp1 = malloc(100);
    char *tmp2 = malloc(200);
    // ...
    free(tmp1);
    free(tmp2);
}
```

**После:**
```c
typedef struct {
    char *mem;
    size_t pos;
    size_t size;
} Arena;

Arena tmpArena;

void initArena(Arena *a, size_t size) {
    a->mem = malloc(size);
    a->pos = 0;
    a->size = size;
}

void *arenaAlloc(Arena *a, size_t size) {
    if (a->pos + size > a->size) return NULL;
    void *ptr = a->mem + a->pos;
    a->pos += size;
    return ptr;
}

void resetArena(Arena *a) {
    a->pos = 0;
}

void process() {
    char *tmp1 = arenaAlloc(&tmpArena, 100);
    char *tmp2 = arenaAlloc(&tmpArena, 200);
    // ...
    resetArena(&tmpArena);
}
```

**Описание:** Оптимизация частых временных аллокаций.

**Оценки:**
- Оптимизация: 9/10
- Архитектура: 8/10
- Производительность: 9/10
- Безопасность: 6/10
- Надежность: 7/10

## 83. Использование thread-local storage для rand()

**До:**
```c
int r = rand();
```

**После:**
```c
#include <threads.h>

_Thread_local unsigned int seed;

void initRand() {
    seed = time(NULL) ^ (uintptr_t)&seed;
}

int rand_r() {
    seed = seed * 1103515245 + 12345;
    return (unsigned int)(seed / 65536) % 32768;
}
```

**Описание:** Потокобезопасный ГПСЧ.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 7/10
- Производительность: 7/10
- Безопасность: 8/10
- Надежность: 8/10

## 84. Введение compile-time проверок типов

**До:**
```c
#define MIN(a,b) ((a) < (b) ? (a) : (b))
```

**После:**
```c
#define MIN(a,b) \
    _Generic((a)+(b), \
        int: ((a) < (b) ? (a) : (b)), \
        double: ((a) < (b) ? (a) : (b)) \
    )
```

**Описание:** Type-safe макросы.

**Оценки:**
- Оптимизация: 6/10
- Архитектура: 8/10
- Производительность: 5/10
- Безопасность: 8/10
- Надежность: 8/10

## 85. Использование strlcpy вместо strncpy

**До:**
```c
strncpy(dest, src, sizeof(dest));
```

**После:**
```c
strlcpy(dest, src, sizeof(dest));
```

**Описание:** Более безопасное копирование строк.

**Оценки:**
- Оптимизация: 5/10
- Архитектура: 7/10
- Производительность: 5/10
- Безопасность: 9/10
- Надежность: 9/10

## 86. Введение intrusive lists

**До:**
```c
typedef struct {
    Data data;
    Node *next;
} Node;
```

**После:**
```c
typedef struct List {
    struct List *next;
} List;

typedef struct {
    Data data;
    List list;
} Node;
```

**Описание:** Более эффективные списки.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 6/10
- Надежность: 7/10

## 87. Использование memmem для поиска подстрок

**До:**
```c
char *findSubstr(char *s, char *sub) {
    // ручной поиск
}
```

**После:**
```c
char *findSubstr(char *s, size_t slen, char *sub, size_t sublen) {
    return memmem(s, slen, sub, sublen);
}
```

**Описание:** Использование оптимизированных библиотечных функций.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 6/10
- Производительность: 8/10
- Безопасность: 7/10
- Надежность: 7/10

## 88. Введение compile-time вычисления размера структур

**До:**
```c
struct Header {
    uint32_t magic;
    uint16_t version;
    // ...
};
// где-то в коде:
assert(sizeof(struct Header) == 12);
```

**После:**
```c
struct Header {
    uint32_t magic;
    uint16_t version;
    // ...
};
static_assert(sizeof(struct Header) == 12, "Invalid header size");
```

**Описание:** Проверка на этапе компиляции.

**Оценки:**
- Оптимизация: 3/10
- Архитектура: 8/10
- Производительность: 1/10
- Безопасность: 9/10
- Надежность: 9/10

## 89. Использование fread/fwrite вместо read/write

**До:**
```c
int fd = open("file", O_RDONLY);
char buf[1024];
read(fd, buf, sizeof(buf));
```

**После:**
```c
FILE *f = fopen("file", "rb");
char buf[1024];
fread(buf, 1, sizeof(buf), f);
```

**Описание:** Буферизированный ввод/вывод.

**Оценки:**
- Оптимизация: 7/10
- Архитектура: 6/10
- Производительность: 7/10
- Безопасность: 6/10
- Надежность: 7/10

## 90. Введение ring buffer

**До:**
```c
#define BUF_SIZE 1024
char buffer[BUF_SIZE];
size_t pos = 0;

void write(char c) {
    if (pos < BUF_SIZE)
        buffer[pos++] = c;
}
```

**После:**
```c
typedef struct {
    char buf[1024];
    size_t head;
    size_t tail;
} RingBuffer;

void rbWrite(RingBuffer *rb, char c) {
    size_t next = (rb->head + 1) % sizeof(rb->buf);
    if (next != rb->tail) {
        rb->buf[rb->head] = c;
        rb->head = next;
    }
}
```

**Описание:** Эффективная циклическая очередь.

**Оценки:**
- Оптимизация: 8/10
- Архитектура: 7/10
- Производительность: 8/10
- Безопасность: 7/10
- Надежность: 8/10

---

Эти 30 примеров продолжают серию рефакторингов, демонстрируя различные техники оптимизации и улучшения кода на Си. Каждый пример сопровождается оценками по пяти критериям, что позволяет оценить влияние изменений на разные аспекты качества кода.
